---
time: 1683172733805
---

## Explanation



Here, we are provided a string and we need to find the longest substring consisting of only a single type of character.



This can be done using a greedy algorithm, by adding 1 to `count` if we receive the same character as the last one, or resetting it to 1, if we don't.
Then we result out the maximum value of `count`.

## Code



<CodeTabs langs={["Python", "Rust", "C++"]}>

```python
s = input()

count = 0
max_count = 0
last = s[0]

for ch in s:
    count = count + 1 if ch == last else 1

    last = ch
    max_count = max(max_count, count)

print(max_count)
```

```rust
use std::io::stdin;

fn main() {
    let s: String = scan_str();
    let mut current: char = s.chars().next().unwrap();
    let mut count = 0;
    let mut max_count = 0;

    for ch in s.chars() {
        if ch == current {
            count += 1;
        } else {
            current = ch.clone();
            count = 1;
        }
        max_count = std::cmp::max(max_count, count);
    }

    println!("{max_count}");
}

fn scan_str() -> String {
    let mut s = String::new();
    stdin().read_line(&mut s).unwrap();
    s
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int main () {
    string s;
    cin >> s;

    int count = 0;
    int max_count = 0;
    char last = s[0];

    for (auto ch : s) {
        count = (ch == last) ? count + 1 : 1;
        last = ch;
        max_count = max(count, max_count);
    }

    cout << max_count << endl;
    return 0;
}

```

</CodeTabs>
